"https://query1.finance.yahoo.com/v10/finance/quoteSummary/",
URLencode(ticker, reserved = TRUE),
"?modules=", paste(modules, collapse = ",")
)
resp <- tryCatch(
GET(url, add_headers(`User-Agent` = "Mozilla/5.0")),
error = function(e) NULL
)
if (is.null(resp) || http_error(resp)) return(NULL)
obj <- tryCatch(fromJSON(content(resp, "text", encoding = "UTF-8"), simplifyVector = FALSE), error = function(e) NULL)
if (is.null(obj)) return(NULL)
res <- obj$quoteSummary$result
if (is.null(res) || length(res) == 0) return(NULL)
res[[1]]
}
pluck_num <- function(x, ..., field = "raw") {
v <- tryCatch(purrr::pluck(x, ..., field), error = function(e) NA_real_)
if (is.null(v)) NA_real_ else as.numeric(v)
}
modules <- c("price","summaryDetail","defaultKeyStatistics","financialData","earningsTrend")
get_vals_one <- function(tk) {
dat <- yf_get_modules(tk, modules)
if (is.null(dat)) return(tibble(Ticker = tk))
price     <- dat$price
summ      <- dat$summaryDetail
ks        <- dat$defaultKeyStatistics
fin       <- dat$financialData
earnTrend <- dat$earningsTrend
px         <- coalesce(pluck_num(price, "regularMarketPrice"),
pluck_num(fin, "currentPrice"))
mktcap     <- coalesce(pluck_num(price, "marketCap"),
pluck_num(summ, "marketCap"))
ev         <- coalesce(pluck_num(fin, "enterpriseValue"),
pluck_num(ks, "enterpriseValue"))
ebitda     <- coalesce(pluck_num(fin, "ebitda"),
pluck_num(ks, "ebitda"))
ps_ttm     <- pluck_num(summ, "priceToSalesTrailing12Months")
pe_ttm     <- coalesce(pluck_num(summ, "trailingPE"),
pluck_num(ks, "trailingPE"))
pcf_ttm    <- pluck_num(ks, "priceToCashflow")
ev_ebitda  <- ifelse(is.finite(ev) && is.finite(ebitda) && ebitda != 0, ev / ebitda, NA_real_)
sales_g   <- pluck_num(fin, "revenueGrowth")
earn_g    <- pluck_num(fin, "earningsGrowth")
trend <- tryCatch(earnTrend$trend, error = function(e) NULL)
if (is.null(trend)) trend <- list()
idx_p1y <- which(purrr::map_chr(trend, ~purrr::pluck(.x, "period", .default = "")) %in% c("+1y","nextYear"))[1]
rev_2026e <- NA_real_; eps_2026e <- NA_real_
if (!is.na(idx_p1y)) {
node <- trend[[idx_p1y]]
rev_2026e <- pluck_num(node, "revenueEstimate", "avg")
eps_2026e <- pluck_num(node, "earningsEstimate", "avg")
}
ps_2026e <- ifelse(is.finite(mktcap) && is.finite(rev_2026e) && rev_2026e > 0, mktcap / rev_2026e, NA_real_)
pe_2026e <- ifelse(is.finite(px) && is.finite(eps_2026e) && eps_2026e > 0, px / eps_2026e, NA_real_)
tibble(
Ticker               = tk,
`P/S (TTM)`          = ps_ttm,
`P/E (TTM)`          = pe_ttm,
`P/CF (TTM)`         = pcf_ttm,
`EV/EBITDA (TTM)`    = ev_ebitda,
`Sales Growth YoY`   = sales_g,
`Earnings Growth YoY`= earn_g,
`P/S (2026e)`        = ps_2026e,
`P/E (2026e)`        = pe_2026e
)
}
# --- Fetch valuations for selected tickers ---
vals <- purrr::map_dfr(tickers_out, function(tk) { Sys.sleep(0.2); get_vals_one(tk) })
# --- Build out_with_vals robustly (no error if Yahoo returns few/zero fields) ---
out_with_vals <- out %>% left_join(vals, by = "Ticker")
metric_cols <- c(
"P/S (TTM)", "P/E (TTM)", "P/CF (TTM)", "EV/EBITDA (TTM)",
"Sales Growth YoY", "Earnings Growth YoY",
"P/S (2026e)", "P/E (2026e)"
)
for (nm in metric_cols) if (!nm %in% names(out_with_vals)) out_with_vals[[nm]] <- NA_real_
out_with_vals <- out_with_vals %>%
mutate(
across(any_of(c("Sales Growth YoY","Earnings Growth YoY")), ~round(as.numeric(.), 4)),
across(any_of(c("P/S (TTM)","P/E (TTM)","P/CF (TTM)","EV/EBITDA (TTM)",
"P/S (2026e)","P/E (2026e)")), ~round(as.numeric(.), 3))
)
# --- Save to Excel ---
wb_path   <- file.path(getwd(), "exquisite shares.xlsx")
sheet_name <- format(Sys.Date(), "%Y-%m-%d")
if (file.exists(wb_path)) {
wb <- loadWorkbook(wb_path)
if (sheet_name %in% names(wb)) removeWorksheet(wb, sheet_name)  # replace on same-day rerun
} else {
wb <- createWorkbook()
}
addWorksheet(wb, sheet_name)
meta <- data.frame(
Metric = c("Run timestamp","Achieved Sortino (daily)","Max assets","Max weight","Sortino cutoff"),
Value  = c(format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
sprintf("%.4f", achieved_sortino),
if (exists("k")) k else NA,
if (exists("max_weight_per_asset")) max_weight_per_asset else NA,
if (exists("sortino_cutoff")) sortino_cutoff else NA),
check.names = FALSE
)
writeData(wb, sheet = sheet_name, x = meta, startRow = 1, startCol = 1, withFilter = FALSE)
start_row_port <- nrow(meta) + 3
writeData(wb, sheet = sheet_name, x = out_with_vals, startRow = start_row_port, startCol = 1, withFilter = TRUE)
freezePane(wb, sheet = sheet_name, firstActiveRow = start_row_port + 1, firstActiveCol = 1)
setColWidths(wb, sheet = sheet_name, cols = 1:ncol(out_with_vals), widths = "auto")
saveWorkbook(wb, wb_path, overwrite = TRUE)
cat(sprintf("\nSaved results + valuations to '%s' (sheet: %s)\n", wb_path, sheet_name))
suppressPackageStartupMessages({
library(quantmod)
library(nloptr)
library(PerformanceAnalytics)
library(dplyr)
library(rvest)
library(xml2)
})
# ===========================
# User knobs (easy to tweak)
# ===========================
start_date <- "2025-02-01"
end_date   <- Sys.Date()
min_obs_days          <- 126      # ~6 months
max_na_frac           <- 0.05     # max 5% NA returns
sortino_cutoff        <- 0.00     # drop assets with Sortino <= this
max_assets_for_opt    <- 30       # cap assets sent to optimizer
max_weight_per_asset  <- 0.15     # per-asset weight cap
use_constant_rf_if_IRX_fails <- 0.02/252  # fallback daily RF
multi_start_runs      <- 5        # random restarts (set to 1 to disable)
set.seed(42)
# Your original tickers to include explicitly (will be deduped)
user_tickers <- c(
"BAC", "SOFI", "ADBE", "DEO", "AMD", "SMCI", "AVGO", "NVDA", "3LDE.L",
"TSM", "MU", "SPGI", "CSCO", "ANET", "HD", "HTHIY", "AZO",
"WTAI.L", "RBOT.L", "ASML.AS", "SONY", "SIE.DE", "SHOP",
"SMT.L", "MSTR", "MTSI", "AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA",
"MPW", "PLTR", "PANW", "TEM", "TDOC", "BIDU", "INTC", "COIN", "KWEB.L", "BABA",
"AIT", "ORLY", "PLNT", "VEA", "SAP.DE", "ORCL",
"NOC", "RTX", "IS04.DE", "LMT", "MLM", "VMC", "STLD", "CAT", "GFS", "BWA",
"APTV", "REL.L", "3GIL.L", "JPM", "TDG", "UNH", "LEN", "POOL", "NUE",
"OXY", "STLA", "ASML", "BRKR", "UBER", "CNC", "TEVA", "ACHC",
"CI", "FLR", "CRWV"
)
# ======================================================
# 1) Pull S&P 500 & FTSE 100 tickers + names + sectors
# ======================================================
get_sp500_tickers_names_sectors <- function() {
url <- "https://en.wikipedia.org/wiki/List_of_S%26P_500_companies"
pg  <- tryCatch(read_html(url), error = function(e) NULL)
if (is.null(pg)) return(list(tickers=character(0),
name_map=setNames(character(0), character(0)),
sector_map=setNames(character(0), character(0))))
tbl <- html_table(html_node(pg, "table"))
# Columns: Symbol, Security, GICS Sector (names may vary slightly)
syms <- gsub("\\.", "-", tbl$Symbol)                     # BRK.B -> BRK-B for Yahoo
names_vec <- tbl$Security
# defensively find GICS Sector column
gics_col <- names(tbl)[grepl("GICS\\s*Sector", names(tbl), ignore.case = TRUE)][1]
sectors_vec <- if (!is.na(gics_col)) tbl[[gics_col]] else rep(NA_character_, length(syms))
syms <- trimws(syms); names_vec <- trimws(names_vec); sectors_vec <- trimws(sectors_vec)
list(
tickers = unique(syms),
name_map   = setNames(names_vec, syms),
sector_map = setNames(sectors_vec, syms)
)
}
get_ftse100_tickers_names_sectors <- function() {
url <- "https://en.wikipedia.org/wiki/FTSE_100_Index"
pg  <- tryCatch(read_html(url), error = function(e) NULL)
if (is.null(pg)) return(list(tickers=character(0),
name_map=setNames(character(0), character(0)),
sector_map=setNames(character(0), character(0))))
tables <- html_table(pg, fill = TRUE)
idx <- which(sapply(tables, function(x) any(grepl("EPIC", names(x), ignore.case = TRUE))))
if (length(idx) == 0) return(list(tickers=character(0),
name_map=setNames(character(0), character(0)),
sector_map=setNames(character(0), character(0))))
t <- tables[[idx[1]]]
epic_col   <- names(t)[grepl("EPIC", names(t), ignore.case = TRUE)][1]
name_col   <- names(t)[grepl("Company", names(t), ignore.case = TRUE)][1]
sector_col <- names(t)[grepl("Sector", names(t), ignore.case = TRUE)][1]
syms <- trimws(t[[epic_col]])
cos  <- trimws(t[[name_col]])
secs <- if (!is.na(sector_col)) trimws(t[[sector_col]]) else rep(NA_character_, length(syms))
ysyms <- paste0(syms, ".L")
list(
tickers = unique(ysyms),
name_map   = setNames(cos, ysyms),
sector_map = setNames(secs, ysyms)
)
}
sp500 <- get_sp500_tickers_names_sectors()
ftse  <- get_ftse100_tickers_names_sectors()
sp500_syms   <- sp500$tickers
ftse100_syms <- ftse$tickers
# Combine universe + maps
all_tickers  <- unique(c(user_tickers, sp500_syms, ftse100_syms))
name_map   <- c(sp500$name_map,   ftse$name_map)
sector_map <- c(sp500$sector_map, ftse$sector_map)
cat("Universe size (after dedupe):", length(all_tickers), "\n")
# Helpers to resolve attributes with fallback
resolve_names <- function(tickers) {
nm <- name_map[tickers]
nm[is.na(nm) | nm == ""] <- tickers[is.na(nm) | nm == ""]
as.character(nm)
}
resolve_sectors <- function(tickers) {
sc <- sector_map[tickers]
sc[is.na(sc) | sc == ""] <- "Unknown"
as.character(sc)
}
# ======================================================
# 2) Download prices (robust)
# ======================================================
get_adj_price <- function(sym, from, to) {
tryCatch({
x <- suppressWarnings(getSymbols(sym, src = "yahoo", from = from, to = to, auto.assign = FALSE))
Ad(x)
}, error = function(e) NULL)
}
plist <- lapply(all_tickers, get_adj_price, from = start_date, to = end_date)
keep  <- !sapply(plist, is.null)
plist <- plist[keep]
tickers_clean <- all_tickers[keep]
stopifnot(length(plist) > 0)
# Per-asset returns first
ret_list <- lapply(plist, function(px) {
r <- ROC(px, type = "discrete")
r[is.infinite(r)] <- NA
r
})
returns <- do.call(merge, ret_list)
colnames(returns) <- tickers_clean
returns <- returns[paste0(start_date, "/", end_date)]  # window
# ======================================================
# 3) Risk-free series and scalar
# ======================================================
rf_series <- tryCatch({
rf_xts <- suppressWarnings(getSymbols("^IRX", src = "yahoo", from = start_date, to = end_date, auto.assign = FALSE))
rf_daily <- Ad(rf_xts)/100/252
rf_daily[index(returns)]
}, error = function(e) NULL)
if (is.null(rf_series) || all(is.na(rf_series))) {
message("Using constant daily RF fallback.")
rf_series <- xts(rep(use_constant_rf_if_IRX_fails, NROW(returns)), order.by = index(returns))
}
rf_scalar <- as.numeric(mean(rf_series, na.rm = TRUE))
# ======================================================
# 4) Pre-screen using SORTINO (per-asset)
# ======================================================
valid_obs <- function(x) sum(!is.na(x))
ret_ok <- returns[, sapply(returns, valid_obs) >= min_obs_days, drop = FALSE]
if (NCOL(ret_ok) == 0) stop("No assets meet min_obs_days; reduce min_obs_days or extend the date window.")
na_frac <- colMeans(is.na(ret_ok))
ret_ok  <- ret_ok[, na_frac <= max_na_frac, drop = FALSE]
if (NCOL(ret_ok) == 0) stop("All assets failed the NA fraction filter; relax max_na_frac or adjust dates.")
asset_sortino <- sapply(ret_ok, function(x) {
x <- as.numeric(x); x <- x[!is.na(x)]
if (length(x) < min_obs_days) return(NA_real_)
ex <- x - rf_scalar
down <- ex[ex < 0]
dd <- sd(down)
if (is.na(dd) || dd == 0) dd <- 1e-8
mean(ex) / dd
})
screen_df <- data.frame(
ticker = colnames(ret_ok),
sortino = asset_sortino,
stringsAsFactors = FALSE
) |>
dplyr::filter(!is.na(sortino)) |>
arrange(desc(sortino)) |>
filter(sortino > sortino_cutoff)
if (nrow(screen_df) == 0) stop("No assets passed the Sortino filter. Try lowering sortino_cutoff or the data window.")
k <- min(max_assets_for_opt, nrow(screen_df))
keep_syms <- screen_df$ticker[1:k]
returns_sel <- ret_ok[, keep_syms]
# Drop rows where all are NA to avoid NA objective at x0
returns_sel <- returns_sel[rowSums(!is.na(returns_sel)) > 0, , drop = FALSE]
cat("Assets after Sortino screening:", NCOL(returns_sel), "\n")
# ======================================================
# 5) Sortino objective (NA-robust) + constraints
# ======================================================
sortino_objective <- function(weights, returns_mat, rf_scalar) {
R  <- returns_mat
R0 <- R; R0[is.na(R0)] <- 0
denom <- as.numeric((!is.na(R)) %*% weights)
num   <- as.numeric(R0 %*% weights)
port  <- ifelse(denom > 0, num / denom, NA)
port  <- port[!is.na(port)]
if (length(port) < 2) return(1e-6 * 1e6)  # big penalty if not enough data
ex   <- port - rf_scalar
down <- ex[ex < 0]
dd   <- sd(down)
if (is.na(dd) || dd == 0) dd <- 1e-8
- mean(ex) / dd
}
eval_g_eq <- function(w) sum(w) - 1
n_assets <- NCOL(returns_sel)
init_w   <- rep(1/n_assets, n_assets)
lb       <- rep(0, n_assets)
ub       <- rep(max_weight_per_asset, n_assets)
opts <- list(
algorithm = "NLOPT_LN_COBYLA",
xtol_rel  = 1e-8,
maxeval   = 2000
)
rand_feasible_weights <- function(n, cap) {
w <- runif(n)
w <- pmin(w, cap)
s <- sum(w)
if (s == 0) rep(1/n, n) else w / s
}
optimize_once <- function(w0) {
res <- nloptr(
x0        = w0,
eval_f    = function(w) sortino_objective(w, returns_sel, rf_scalar),
lb        = lb,
ub        = ub,
eval_g_eq = eval_g_eq,
opts      = opts
)
w <- pmax(0, pmin(res$solution, ub))
w <- w / sum(w)
list(value = res$objective, weights = w, status = res$status, msg = res$message)
}
best <- optimize_once(init_w)
if (multi_start_runs > 1) {
for (i in 2:multi_start_runs) {
w0 <- rand_feasible_weights(n_assets, max_weight_per_asset)
try_res <- optimize_once(w0)
if (is.finite(try_res$value) && try_res$value < best$value) best <- try_res
}
}
opt_w <- best$weights
# ======================================================
# 6) Results (Sector + Name + Ticker + Weight)
# ======================================================
cat("\n---- Screened universe (top by Sortino) ----\n")
print(head(screen_df, max_assets_for_opt))
cat("\n---- Optimal Portfolio Weights (max Sortino) ----\n")
tickers_out <- colnames(returns_sel)
names_out   <- resolve_names(tickers_out)
sectors_out <- resolve_sectors(tickers_out)
out <- data.frame(
Sector = sectors_out,
Name   = names_out,
Ticker = tickers_out,
Weight = round(opt_w, 4),
stringsAsFactors = FALSE
)
out <- out[order(-out$Weight), ]
print(out, row.names = FALSE)
# Portfolio Sortino achieved (daily) — NA-robust aggregation
R  <- returns_sel; R0 <- R; R0[is.na(R0)] <- 0
denom <- as.numeric((!is.na(R)) %*% opt_w)
num   <- as.numeric(R0 %*% opt_w)
port  <- ifelse(denom > 0, num / denom, NA)
port  <- port[!is.na(port)]
excess_port <- port - rf_scalar
dd <- sd(excess_port[excess_port < 0])
dd <- ifelse(is.na(dd) || dd == 0, 1e-8, dd)
achieved_sortino <- mean(excess_port) / dd
cat(sprintf("\nAchieved Sortino (daily): %.4f\n", achieved_sortino))
cat(sprintf("Sortino cutoff: %.2f | Max assets: %d | Max w: %.2f | Starts: %d\n",
sortino_cutoff, k, max_weight_per_asset, multi_start_runs))
# ========= Step 7 + 8: Valuations + Save to Excel (one-shot) =========
suppressPackageStartupMessages({
library(dplyr)
library(purrr)
library(httr)
library(jsonlite)
library(openxlsx)
library(tibble)
})
# --- sanity checks: we need `out`, `tickers_out`, and `achieved_sortino` from Step 6 ---
if (!exists("out") || !exists("tickers_out")) {
stop("I need `out` and `tickers_out` from Step 6. Please run the optimization first.")
}
if (!exists("achieved_sortino")) achieved_sortino <- NA_real_
# --- Yahoo helpers (safe to re-define) ---
yf_get_modules <- function(ticker, modules) {
url <- paste0(
"https://query1.finance.yahoo.com/v10/finance/quoteSummary/",
URLencode(ticker, reserved = TRUE),
"?modules=", paste(modules, collapse = ",")
)
resp <- tryCatch(
GET(url, add_headers(`User-Agent` = "Mozilla/5.0")),
error = function(e) NULL
)
if (is.null(resp) || http_error(resp)) return(NULL)
obj <- tryCatch(fromJSON(content(resp, "text", encoding = "UTF-8"), simplifyVector = FALSE), error = function(e) NULL)
if (is.null(obj)) return(NULL)
res <- obj$quoteSummary$result
if (is.null(res) || length(res) == 0) return(NULL)
res[[1]]
}
pluck_num <- function(x, ..., field = "raw") {
v <- tryCatch(purrr::pluck(x, ..., field), error = function(e) NA_real_)
if (is.null(v)) NA_real_ else as.numeric(v)
}
modules <- c("price","summaryDetail","defaultKeyStatistics","financialData","earningsTrend")
get_vals_one <- function(tk) {
dat <- yf_get_modules(tk, modules)
if (is.null(dat)) return(tibble(Ticker = tk))
price     <- dat$price
summ      <- dat$summaryDetail
ks        <- dat$defaultKeyStatistics
fin       <- dat$financialData
earnTrend <- dat$earningsTrend
px         <- coalesce(pluck_num(price, "regularMarketPrice"),
pluck_num(fin, "currentPrice"))
mktcap     <- coalesce(pluck_num(price, "marketCap"),
pluck_num(summ, "marketCap"))
ev         <- coalesce(pluck_num(fin, "enterpriseValue"),
pluck_num(ks, "enterpriseValue"))
ebitda     <- coalesce(pluck_num(fin, "ebitda"),
pluck_num(ks, "ebitda"))
ps_ttm     <- pluck_num(summ, "priceToSalesTrailing12Months")
pe_ttm     <- coalesce(pluck_num(summ, "trailingPE"),
pluck_num(ks, "trailingPE"))
pcf_ttm    <- pluck_num(ks, "priceToCashflow")
ev_ebitda  <- ifelse(is.finite(ev) && is.finite(ebitda) && ebitda != 0, ev / ebitda, NA_real_)
sales_g   <- pluck_num(fin, "revenueGrowth")
earn_g    <- pluck_num(fin, "earningsGrowth")
trend <- tryCatch(earnTrend$trend, error = function(e) NULL)
if (is.null(trend)) trend <- list()
idx_p1y <- which(purrr::map_chr(trend, ~purrr::pluck(.x, "period", .default = "")) %in% c("+1y","nextYear"))[1]
rev_2026e <- NA_real_; eps_2026e <- NA_real_
if (!is.na(idx_p1y)) {
node <- trend[[idx_p1y]]
rev_2026e <- pluck_num(node, "revenueEstimate", "avg")
eps_2026e <- pluck_num(node, "earningsEstimate", "avg")
}
ps_2026e <- ifelse(is.finite(mktcap) && is.finite(rev_2026e) && rev_2026e > 0, mktcap / rev_2026e, NA_real_)
pe_2026e <- ifelse(is.finite(px) && is.finite(eps_2026e) && eps_2026e > 0, px / eps_2026e, NA_real_)
tibble(
Ticker               = tk,
`P/S (TTM)`          = ps_ttm,
`P/E (TTM)`          = pe_ttm,
`P/CF (TTM)`         = pcf_ttm,
`EV/EBITDA (TTM)`    = ev_ebitda,
`Sales Growth YoY`   = sales_g,
`Earnings Growth YoY`= earn_g,
`P/S (2026e)`        = ps_2026e,
`P/E (2026e)`        = pe_2026e
)
}
# --- Fetch valuations for selected tickers ---
vals <- purrr::map_dfr(tickers_out, function(tk) { Sys.sleep(0.2); get_vals_one(tk) })
# --- Build out_with_vals robustly (no error if Yahoo returns few/zero fields) ---
out_with_vals <- out %>% left_join(vals, by = "Ticker")
metric_cols <- c(
"P/S (TTM)", "P/E (TTM)", "P/CF (TTM)", "EV/EBITDA (TTM)",
"Sales Growth YoY", "Earnings Growth YoY",
"P/S (2026e)", "P/E (2026e)"
)
for (nm in metric_cols) if (!nm %in% names(out_with_vals)) out_with_vals[[nm]] <- NA_real_
out_with_vals <- out_with_vals %>%
mutate(
across(any_of(c("Sales Growth YoY","Earnings Growth YoY")), ~round(as.numeric(.), 4)),
across(any_of(c("P/S (TTM)","P/E (TTM)","P/CF (TTM)","EV/EBITDA (TTM)",
"P/S (2026e)","P/E (2026e)")), ~round(as.numeric(.), 3))
)
# --- Save to Excel ---
wb_path   <- file.path(getwd(), "exquisite shares.xlsx")
sheet_name <- format(Sys.Date(), "%Y-%m-%d")
if (file.exists(wb_path)) {
wb <- loadWorkbook(wb_path)
if (sheet_name %in% names(wb)) removeWorksheet(wb, sheet_name)  # replace on same-day rerun
} else {
wb <- createWorkbook()
}
addWorksheet(wb, sheet_name)
meta <- data.frame(
Metric = c("Run timestamp","Achieved Sortino (daily)","Max assets","Max weight","Sortino cutoff"),
Value  = c(format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
sprintf("%.4f", achieved_sortino),
if (exists("k")) k else NA,
if (exists("max_weight_per_asset")) max_weight_per_asset else NA,
if (exists("sortino_cutoff")) sortino_cutoff else NA),
check.names = FALSE
)
writeData(wb, sheet = sheet_name, x = meta, startRow = 1, startCol = 1, withFilter = FALSE)
start_row_port <- nrow(meta) + 3
writeData(wb, sheet = sheet_name, x = out_with_vals, startRow = start_row_port, startCol = 1, withFilter = TRUE)
freezePane(wb, sheet = sheet_name, firstActiveRow = start_row_port + 1, firstActiveCol = 1)
setColWidths(wb, sheet = sheet_name, cols = 1:ncol(out_with_vals), widths = "auto")
saveWorkbook(wb, wb_path, overwrite = TRUE)
cat(sprintf("\nSaved results + valuations to '%s' (sheet: %s)\n", wb_path, sheet_name))
# Option 1: via code
learnr::run_tutorial("01-data-visualization", package = "r4ds.tutorials")
# open interactive tutorial in the package 'learnr'
learnr::run_tutorial("ex-data-basics", package = "learnr")
learnr::run_tutorial("data-visualization", package = "r4ds")
# Option 2: discover tutorials installed on your system
learnr::available_tutorials("r4ds.tutorials")
# Option 1: via code
learnr::run_tutorial("01-data-visualization", package = "r4ds.tutorials")
# Open the library to read csv comma delimited files.
library(readr)
# Create the object pipr_csv to store the data
pipr_csv <- read_csv("data/pipr_monthly.csv", skip =7)  # adjust file name
setwd ("C:/Users/Cam/Documents/GitProjects/a- Cambridge RM01 supervisions")
# Open the library to read csv comma delimited files.
library(readr)
# Create the object pipr_csv to store the data
pipr_csv <- read_csv("data/pipr_monthly.csv", skip =7)  # adjust file name
# colums/variable names
names(pipr_csv)
install.packages("AmesHousing")
install.packages("janitor")
